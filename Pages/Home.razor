@page "/"

@inject HttpClient Http
@inject Albatross.Services.AbuseIPDBService AbuseIPDBService
@using System.Text.Json
@using System.Linq
@inject IJSRuntime JSRuntime

<PageTitle>Albatross</PageTitle>

<!-- External CSS and JS references -->
<link rel="stylesheet" href="css/json-formatter.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/vs2015.min.css">
<script>
    // Global flag to track highlight.js availability
    window.hljsReady = false;
    
    // Load highlight.js scripts in proper order
    (function() {
        // First load the main highlight.js library
        var hljs_script = document.createElement('script');
        hljs_script.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js';
        hljs_script.onload = function() {
            // Then load the JSON language support
            var json_script = document.createElement('script');
            json_script.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/json.min.js';
            json_script.onload = function() {
                // Finally load our custom JSON highlighting
                var custom_script = document.createElement('script');
                custom_script.src = 'js/json-highlight.js';
                custom_script.onload = function() {
                    // Mark as ready once everything is loaded
                    window.hljsReady = true;
                    console.log('highlight.js and JSON support loaded successfully');
                };
                document.head.appendChild(custom_script);
            };
            document.head.appendChild(json_script);
        };
        document.head.appendChild(hljs_script);    })();
    
    // Force compact card headers after page load
    window.addEventListener('DOMContentLoaded', function() {
        function forceCompactHeaders() {
            const cardHeaders = document.querySelectorAll('.card-header');
            cardHeaders.forEach(header => {
                header.style.setProperty('padding', '0.25rem 1rem', 'important');
                header.style.setProperty('height', '32px', 'important');
                header.style.setProperty('max-height', '32px', 'important');
                header.style.setProperty('min-height', '32px', 'important');
                header.style.setProperty('display', 'flex', 'important');
                header.style.setProperty('align-items', 'center', 'important');
                header.style.setProperty('justify-content', 'space-between', 'important');
                header.style.setProperty('box-sizing', 'border-box', 'important');
                header.style.setProperty('overflow', 'hidden', 'important');
                
                const headings = header.querySelectorAll('h4, h5');
                headings.forEach(heading => {
                    heading.style.setProperty('font-size', '0.9rem', 'important');
                    heading.style.setProperty('line-height', '1.1', 'important');
                    heading.style.setProperty('margin', '0', 'important');
                    heading.style.setProperty('padding', '0', 'important');
                });
            });
        }
        
        // Apply immediately
        forceCompactHeaders();
        
        // Also apply after a short delay to catch any dynamic content
        setTimeout(forceCompactHeaders, 500);
        
        // Set up a mutation observer to catch dynamically added card headers
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === 1) { // Element node
                            const newHeaders = node.querySelectorAll ? node.querySelectorAll('.card-header') : [];
                            newHeaders.forEach(header => {
                                header.style.setProperty('padding', '0.25rem 1rem', 'important');
                                header.style.setProperty('height', '32px', 'important');
                                header.style.setProperty('max-height', '32px', 'important');
                                header.style.setProperty('min-height', '32px', 'important');
                                header.style.setProperty('display', 'flex', 'important');
                                header.style.setProperty('align-items', 'center', 'important');
                                header.style.setProperty('justify-content', 'space-between', 'important');
                                header.style.setProperty('box-sizing', 'border-box', 'important');
                            });
                        }
                    });
                }
            });
        });
        observer.observe(document.body, { childList: true, subtree: true });
    });
</script>

<center>

<!-- 
<pre><b>
   ________                __   ________     _____                      __  
  / ____/ /___  __  ______/ /  /  _/ __ \   / ___/___  ____ ___________/ /_ 
 / /   / / __ \/ / / / __  /   / // /_/ /   \__ \/ _ \/ __ `/ ___/ ___/ __ \
/ /___/ / /_/ / /_/ / /_/ /  _/ // ____/   ___/ /  __/ /_/ / /  / /__/ / / /
\____/_/\____/\__,_/\__,_/  /___/_/       /____/\___/\__,_/_/   \___/_/ /_/ 
</b></pre><br>
-->
<img src="/images/ascii-text-art.png" alt="CloudIPSearch" width="30%" style="padding-bottom: 5px;" border="0"/> <br>
<img src="/images/ascii-text-art-albatross.png" alt="ascii-text-art-albatross" width=10% border="0" /> <br><br>
<div class="ascii-art-pixel-matrix" role="img" aria-label="ASCII art pixel matrix">
    <div class="pixel-matrix__grid">
@foreach (var row in AsciiArtPixelMatrix)
{
    foreach (var shade in row)
    {
        <span class="pixel-matrix__pixel @GetPixelShadeClass(shade)"></span>
    }
}
    </div>
</div>
<br><br>

<input @bind="ipAddress" placeholder="Enter public IPv4/IPv6 address (optionally: ip;maxDays)" class="ip-input form-control" />
<button class="btn btn-primary" @onclick="ValidateAndSearchAsync" disabled="@isSearching">Search</button>
<button class="btn btn-info" @onclick="ToggleDescription" style="margin-left: 10px;">
    <span class="oi oi-info"></span> About
</button>
<button class="btn btn-warning" @onclick="CheckAbuseIPDBAsync" disabled="@isCheckingAbuse" style="margin-left: 10px;">
    <span class="oi oi-shield"></span> Check IP Reputation
</button>
<br><br>

@if (!string.IsNullOrEmpty(statusMessage))
{
    <p class="text-center" style="max-width: 600px; margin: 10px auto; font-weight: 500;">
        @statusMessage
    </p>
}

@if (showDescription)
{    <div class="description-panel">
        <div class="card">            
            <div class="card-header d-flex justify-content-between align-items-center" style="padding: 0.25rem 1rem !important; min-height: 32px !important; height: 32px !important; max-height: 32px !important; box-sizing: border-box !important; overflow: hidden !important;">
                <h5 style="margin: 0 !important; padding: 0 !important; font-size: 0.9rem !important; line-height: 1.1 !important; font-weight: 500 !important;">About Albatross IP Analysis</h5>
                <button class="btn btn-sm btn-close" @onclick="ToggleDescription" style="font-size: 0.75rem !important; padding: 0.125rem 0.25rem !important; margin: 0 !important; height: 24px !important; width: 24px !important; display: flex !important; align-items: center !important; justify-content: center !important; flex-shrink: 0 !important;"></button>            </div>              
            <div class="card-body">
                <p><strong>Albatross</strong> provides comprehensive IP address analysis combining cloud provider identification with security reputation checking.</p>
                
                <h6>🔍 <strong>IP Analysis Features:</strong></h6>
                <ul>
                    <li><strong>Cloud Detection:</strong> Identifies if IPs belong to AWS, Azure, GCP, or Oracle Cloud</li>
                    <li><strong>Abuse Checking:</strong> Queries AbuseIPDB for security reputation and threat intelligence</li>
                    <li><strong>Network Information:</strong> Provides ASN details and network ownership via Cloudflare Radar</li>
                    <li><strong>AI-Powered Analysis:</strong> Uses Cloudflare Workers AI (Llama 3.1 70B) to generate risk assessments and actionable recommendations</li>
                </ul>

                <h6>📝 <strong>Input Formats:</strong></h6>
                <ul>
                    <li><code>8.8.8.8</code> - Standard IP lookup (30 days of abuse reports)</li>
                    <li><code>8.8.8.8;60</code> - Custom report age (60 days of history)</li>
                    <li><code>2001:4860:4860::8888</code> - IPv6 addresses supported</li>
                </ul>

                <h6>🤖 <strong>AI Reputation Analysis:</strong></h6>
                <p>Automatically analyzes IP reputation data using Cloudflare Workers AI with Llama 3.1 70B Instruct model. Provides risk level assessment (low/medium/high/critical), trust score (0-100), summary of abuse event patterns, and security recommendations based on real-time threat intelligence.</p>

                <h6>🔒 <strong>Security:</strong></h6>
                <p>All requests use HMAC-SHA256 authentication with timestamp validation. Only public routable IP addresses are accepted (private networks like 10.x.x.x, 192.168.x.x, and 127.x.x.x are blocked).</p>

                <p><small class="text-muted">Data provided by AbuseIPDB, Cloudflare Radar, Cloudflare Workers AI, and official cloud provider IP manifests.</small></p>
            </div>
        </div>
    </div>
}

<!-- Fixed container for search results to prevent layout shifting -->
<div class="search-results-container @(HasSearchResults() || abuseIpResult != null ? "has-results" : "") @(isSearching || isCheckingAbuse ? "searching" : "")">    @if (isSearching && !isCheckingAbuse)
    {
        <div class="spinner-container">
            <div class="loading-bars">
                <div class="bar1"></div>
                <div class="bar2"></div>
                <div class="bar3"></div>
                <div class="bar4"></div>
                <div class="bar5"></div>
            </div>
            <small class="text-muted">Searching cloud IP ranges...</small>
        </div>
    }
    else if (!isSearching)
    {
        @if (azureMatchedServices != null && azureMatchedServices.Any())
        {
            <div class="results">
                <h3>Matching Azure Services:</h3>
                <div>
                    @foreach (var service in azureMatchedServices)
                    {
                        <div class="service-match">
                            <strong>@service.ServiceInfo</strong>
                            <br />
                            <small class="text-muted">CIDR Range: @service.CidrRange</small>
                        </div>
                    }
                </div>
            </div>
        }

        @if (awsMatchedServices != null && awsMatchedServices.Any())
        {
            <div class="results">
                <h3>Matching AWS Services:</h3>
                <div>
                    @foreach (var service in awsMatchedServices)
                    {
                        <div class="service-match">
                            <strong>@service.ServiceInfo</strong>
                            <br />
                            <small class="text-muted">CIDR Range: @service.CidrRange</small>
                        </div>
                    }
                </div>
            </div>
        }

        @if (gcpMatchedServices != null && gcpMatchedServices.Any())
        {
            <div class="results">
                <h3>Matching GCP Services:</h3>
                <div>
                    @foreach (var service in gcpMatchedServices)
                    {
                        <div class="service-match">
                            <strong>@service.ServiceInfo</strong>
                            <br />
                            <small class="text-muted">CIDR Range: @service.CidrRange</small>
                        </div>
                    }
                </div>
            </div>
        }

        @if (oracleMatchedServices != null && oracleMatchedServices.Any())
        {
            <div class="results">
                <h3>Matching Oracle Cloud Services:</h3>
                <div>
                    @foreach (var service in oracleMatchedServices)
                    {
                        <div class="service-match">
                            <strong>@service.ServiceInfo</strong>
                            <br />
                            <small class="text-muted">CIDR Range: @service.CidrRange</small>
                        </div>
                    }
                </div>
            </div>
        }
    }    @if (isCheckingAbuse)
    {
        <div class="spinner-container">
            <div class="loading-bars abuse-check">
                <div class="bar1"></div>
                <div class="bar2"></div>
                <div class="bar3"></div>
                <div class="bar4"></div>
                <div class="bar5"></div>
            </div>
            <small class="text-muted">Checking IP reputation...</small>
        </div>
    }@if (abuseIpResult != null)
    {
        <center>
        <div class="results card-container">
            <h3>IP Reputation Results for @(abuseIpResult.Data?.IpAddress ?? ipAddress)</h3>        
            <div class="card">            
                <div class="card-header d-flex justify-content-between align-items-center" style="padding: 0.25rem 1rem !important; min-height: 32px !important; height: 32px !important; max-height: 32px !important; box-sizing: border-box !important; overflow: hidden !important;">
                    <h5 style="margin: 0 !important; padding: 0 !important; font-size: 0.9rem !important; line-height: 1.1 !important; font-weight: 500 !important;">AbuseIPDB JSON Response</h5>
                    <button class="btn btn-sm btn-outline-secondary" @onclick="ToggleJsonDisplay" style="font-size: 0.75rem !important; padding: 0.125rem 0.25rem !important; margin: 0 !important; height: 24px !important; display: flex !important; align-items: center !important; justify-content: center !important; flex-shrink: 0 !important;">
                        @(showJson ? "Hide JSON" : "Show JSON")
                    </button>
                </div>
                @if (showJson)
                {
                    <div class="card-body json-container">                        
                        <pre class="bg-dark text-light p-3 rounded json-output" id="jsonOutput">@formattedJson</pre>
                    </div>
                }
            </div>
        </div>
        </center>
    }
</div>

</center>

@code {
    private const int AsciiArtPixelMatrixColumns = 240;
    private const int AsciiArtPixelMatrixRows = 44;
    private static readonly int[][] AsciiArtPixelMatrix = BuildAsciiArtPixelMatrix();

    private string ipAddress = string.Empty;private string statusMessage = string.Empty;
    private List<CloudMatch>? azureMatchedServices;
    private List<CloudMatch>? awsMatchedServices;
    private List<CloudMatch>? gcpMatchedServices;
    private List<CloudMatch>? oracleMatchedServices;
    private bool isSearching = false;
    private bool showDescription = false;
    private bool isCheckingAbuse = false;
    private bool showJson = true; // Default to showing JSON
    private string formattedJson = string.Empty;
    private Albatross.Services.AbuseIPDBApiResponse? abuseIpResult;

    private static string GetPixelShadeClass(int value) => value switch
    {
        1 => "pixel-matrix__pixel--edge",
        2 => "pixel-matrix__pixel--mid",
        3 => "pixel-matrix__pixel--dark",
        4 => "pixel-matrix__pixel--core",
        _ => "pixel-matrix__pixel--empty"
    };

    private static int[][] BuildAsciiArtPixelMatrix()
    {
        string rawMatrix = @"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111222222222222222221000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022223444444444444444442100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000122223433333333333333332100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001222223333344444333334343444433332100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001222223433444444444434333334334342100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111222333334433344443333334333434434343222200000000000000000000000000000000000000000000000111111222222222222222222222111100000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000022222222223444444444434334342121244343434434334444310000000000000000000000000000000000000000000000122222344444444444444444444222100000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000022222222223433444444433334343222233333334333333334311000000000000000000000000000000000000000000111222222343433333333333444434222110000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000122222222222233444444443444334444334434343444343444434343434334321000000000000000000000000000122223433443444444444444444444433433343433344433334211000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000122222222222244444444443333333333334334333334333334334333433334311000000000000000000000000000122223333333444444444444444444444433444444443443334211000000000000000000
000000000000000000000000000000000000000000000000000000000000000000111111111222333333333332333444443434333434334334333434333434434333434334333221100000000000000001111111233333444444444444444444444444322334322323234334333333221100000000000000
000000000000000000000000000000000000000000000000000000000000000001222222222223444444444421213443443434333434334334333434333334434333434333444442110000000000000002222222344443444444443333333333333334221344211212224224344444432100000000000000
000000000000000000000000000000000000000000000000000000000011111111222222222223333443333322223333333333333333334334333334333334333333433333333332211100001111110012222222243444444444443344433333433334322334322222223223333333332211000000000000
000000000000000000000000000000000000000000000000000011222234444444444444444443222221111122222222233444334444334434343434343444434343434343444334444322223444442222222222243444444443333344433343434343444433444444432222222222344444211000000000
000000000000000000000000000000000000000000000000000001222234333334444444444443222221111122222222244433333333334333333333333334333333333333334333334322223333332222222222343444444444444444434333333333433333333333432222222222344444211000000000
000000000000000000000000000000111111111111112333333333443444444343222222222221000000000000112211222233333434334334343434343444434333434333444333434333333344333333332222223444444322222222332343433333443433343433433333333333222222333210000000
000000000000000000000000000000111111111111222444444444444444444443222221111110000000000000011211222244433433334334333334333334434333434333444333333444444344334444342222123344434322222222341344444444433433343433344444444444222222344210000000
000000000000000000000001111111111111111111222333333333333333333332111111111110000000000000001111222233333333334334333444333334434333434333434333333333333344333334443333234333333211111221232333333333343333343333343333333334322222333322100000
000000000000000000000012222222222111122222211111111111111111111110000000000000000000000000000111222222234434334334343444343444434343434343444333444333444344343444444444444322101000000011112222211112343433343433344433343433444444434444211000
000000000000000000000012222222222111122222211111111111111111111110000000000000000000000000000111222222233433334334333444333334333333333333334333333333333344333334444444434322111000000011112222221112343433343333333433333333333333433333211000
000000000000000111111111111111111111111111111233333333322333333321110000000000000000000000000001111112222223434444444444343444434343434343444333444333444344343434444444444433322111000000000001111112222124332333333432343434344434434343333211
000000000000000111111111111110111111111011111234444444422444443421110000000000000000000000000000111112222223434444444334333334434333434333434333333333333344333433333344444434312101000000000001111112222114431344444431343333333333433333434210
000000000000112111111111111122222222222222111122222222222233333422111211000000000000000000000000100001111212334444444334333334434333434333434333334333334344333434343434444434323222211100000000000011111112221222222332343344444344444444444322
000000000111234222222222222234444444444443211111111111111112443422223421100000000000000000000000000000000111234333333434343444434333434333444333434333434344343434343433333343444444442100000000000000000001111111110344444444444444444444444444
000000000111233222222222222233333333333343211111111111111112333322222422100000000000000000000000000000000111233334333334333334333333433333334333333333333344333433333434344333333333332110000000000000000001111111111333333344444344444444444333
000111221111111111111122333333334333344443333321000000000000111111233333333110000000000000000000000000000000012244343434343444434343434343444333444333444344343434343434344344344443433333332000000000000000000000000111111111111111111111111111
000111222111111111111112334444344444443333444421000000000000111111234444443210000000000000000000000000000000011233333334333334334333434333334333333333333344333434333434344333344443333444432000000000000000000000000111111111111111111111111111
011111111100000011111122333333433333334343322221000000000000000001122222222111000000000000000000000000001112223344333434333434434333434333444333334333334344333434343434344343334443333343433210000000000000000000000000000000000000000000000000
112111111100000001111122443222422222234443211110000000000000000000111111111121110000000000000000000000111223444434343434343434434333434333444333334333334344343434343434344343433333333344434310000000000000000000000000000000000000000000000000
112111111100000001111112333222322222233333211110000000000000000000111111111121110000000000000000000001111223434334333334333334333333433333334333333333333344333433333433344333333333333343334320000000000000000000000000000000000000000000000000
111000000000000000000000111111112222422111100000000000000000000000000111111111111111222222222222222222222223434434323434343444434343434343444333444333444344343434343434344344433444433444434222210000000000000000000000000000000000000000000000
111000000000000000000000111111112222432111100000000000000000000000000111111111111111222222222222222222222223444334313444333334334333434333334333333333333344333433333433344333333333333343334222210000000000000000000000000000000000000000000000
000000000000000000000000000000001111111000000000000000000000000000001222222222222222222222222222222222222222223434333323433434433333433333434333434333434344343434343434344333333343333343434333331100000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000001222222222222222222222222222222222222222213434342213433434444344444344444333334333334344343434343434344444444443444444433444432100000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000001222222222222222222222222222222222222222223434343223433343333333333333333333333333333344333433333433333333333343333333333443432210000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000011122222222222222222222222222222244443244334334323433342222222222222223433334333334344333434333433332222222344322222343333434310000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000011122222222222222222222222222222233342234334444323444442222222222222223444444444444444344444344444332222222344322222344444444310000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000001111122222222222112223333333333344343334343222222222222222222222222222222222222222222222222222222343333332222221111111122222220000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000111122222222221111223443444444444334444442122222222222222222222222222222222222222222222222222211244444442222221111111112222220000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000111122222222221112223433443333344333333332222222222222222222222222222222222222222222222222222222333333332222111111111111111110000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000111111111111122223433443434333434322222222222222222244444442222222222222222222222222222223444322221111111000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000111111111111122223443443444343434322222222222222222243333342222222222222222222222222222223434322221111111000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011112222222222211111111111111111111111111122222222222222222222222222222222221111111110000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111222222222111111111111111111111111111122222222222222222222222222222222221111111110000000000000000000000000000000000000000000000000000000000000000000";

        return rawMatrix
            .Split('\n')
            .Where(line => !string.IsNullOrEmpty(line))
            .Select(row => row.Select(ch => ch - '0').ToArray())
            .ToArray();
    }
    
    // Called when component is initialized
    protected override void OnInitialized()
    {
        base.OnInitialized();
    }
    
    // Called after the component has rendered
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!string.IsNullOrEmpty(formattedJson) && showJson)
        {
            await ApplyJsonHighlighting();
        }
    }
      // Method to apply syntax highlighting to JSON
    private async Task ApplyJsonHighlighting()
    {
        try
        {
            // Check if highlight.js is ready before trying to use it
            bool isReady = await JSRuntime.InvokeAsync<bool>("eval", "window.hljsReady === true");
            if (isReady)
            {
                await JSRuntime.InvokeVoidAsync("highlightJson");
            }
            else
            {
                // Retry after a short delay if not ready
                await Task.Delay(100);
                await ApplyJsonHighlighting();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error highlighting JSON: {ex.Message}");
        }
    }

    private void ToggleDescription()
    {
        showDescription = !showDescription;
    }
    
    private async void ToggleJsonDisplay()
    {
        showJson = !showJson;
        
        // When toggling to show the JSON, apply highlighting after render
        if (showJson && !string.IsNullOrEmpty(formattedJson))
        {
            StateHasChanged();
            await Task.Delay(50); // Small delay to ensure rendering completes
            await ApplyJsonHighlighting();
        }
    }

    private async Task ValidateAndSearchAsync()
    {
        await ValidateAndSearch();
    }    private async Task CheckAbuseIPDBAsync()
    {
        if (!IsValidIPAddress(ipAddress))
        {
            statusMessage = "Invalid IP address. Please enter a valid public routable IPv4 or IPv6 address (private/reserved ranges are not allowed).";
            return;
        }        isCheckingAbuse = true;
        statusMessage = "Checking IP reputation...";
        abuseIpResult = null;
        formattedJson = string.Empty;
        StateHasChanged();

        try
        {
            // Log to browser console for debugging
            await JSRuntime.InvokeVoidAsync("console.log", "Checking IP: " + ipAddress);
            
            abuseIpResult = await AbuseIPDBService.CheckIPAsync(ipAddress, 30, true);
            
            // Format the JSON for display
            var options = new JsonSerializerOptions { WriteIndented = true };
            formattedJson = JsonSerializer.Serialize(abuseIpResult, options);
            
            // Log the JSON to browser console
            await JSRuntime.InvokeVoidAsync("console.log", "Response JSON: " + formattedJson);
            
            // Debug check
            if (string.IsNullOrEmpty(formattedJson))
            {
                formattedJson = "No data returned from API.";
            }
            
            statusMessage = "IP reputation check completed.";
            
            // Force UI update
            StateHasChanged();
            
            // Apply syntax highlighting after the component has rendered
            await Task.Delay(50); // Small delay to ensure rendering completes
            await ApplyJsonHighlighting();
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error: " + ex.Message);
            statusMessage = $"Error checking IP reputation: {ex.Message}";
            formattedJson = $"Error: {ex.Message}";
        }        finally
        {
            isCheckingAbuse = false;
        }}    private async Task ValidateAndSearch()
    {
        azureMatchedServices = null;
        awsMatchedServices = null;
        gcpMatchedServices = null;
        oracleMatchedServices = null;        
        if (!IsValidIPAddress(ipAddress))
        {
            statusMessage = "Invalid IP address. Please enter a valid public routable IPv4 or IPv6 address (private/reserved ranges are not allowed).";
            return;
        }        isSearching = true;
        statusMessage = "Searching IP ranges...";
        StateHasChanged();        try
        {
            // Extract just the IP address part (strip ;maxDays if present)
            string actualIpAddress = ipAddress.Contains(';') 
                ? ipAddress.Split(';', 2)[0].Trim() 
                : ipAddress.Trim();
            
            // Parse the entered IP address
            IPAddress enteredIp = IPAddress.Parse(actualIpAddress);

            // Load all manifest files in parallel for optimal performance
            var downloadTasks = new[]
            {
                Http.GetStringAsync("ip-manifests/Azure.json"),
                Http.GetStringAsync("ip-manifests/AWS.json"),
                Http.GetStringAsync("ip-manifests/GCP.json"),
                Http.GetStringAsync("ip-manifests/Oracle.json")
            };

            statusMessage = "Loading cloud IP manifests...";
            StateHasChanged();

            // Wait for all downloads to complete
            var manifestContents = await Task.WhenAll(downloadTasks);

            statusMessage = "Searching IP ranges...";
            StateHasChanged();

            // Process all manifests in parallel using separate threads
            var searchTasks = new[]
            {
                Task.Run(() => SearchAzureRanges(enteredIp, manifestContents[0])),
                Task.Run(() => SearchAwsRanges(enteredIp, manifestContents[1])),
                Task.Run(() => SearchGcpRanges(enteredIp, manifestContents[2])),
                Task.Run(() => SearchOracleRanges(enteredIp, manifestContents[3]))
            };

            // Wait for all searches to complete
            var searchResults = await Task.WhenAll(searchTasks);

            // Assign results
            azureMatchedServices = searchResults[0];
            awsMatchedServices = searchResults[1];
            gcpMatchedServices = searchResults[2];
            oracleMatchedServices = searchResults[3];

            // Determine if any matches were found
            bool foundMatch = (azureMatchedServices?.Count > 0) || 
                             (awsMatchedServices?.Count > 0) || 
                             (gcpMatchedServices?.Count > 0) ||
                             (oracleMatchedServices?.Count > 0);

            if (foundMatch)
            {
                var totalMatches = (azureMatchedServices?.Count ?? 0) + 
                                 (awsMatchedServices?.Count ?? 0) + 
                                 (gcpMatchedServices?.Count ?? 0) +
                                 (oracleMatchedServices?.Count ?? 0);
                statusMessage = $"Found {totalMatches} matching cloud service(s)!";
            }
            else
            {
                statusMessage = "No matching cloud services found for this IP address.";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error during search: {ex.Message}";
            await JSRuntime.InvokeVoidAsync("console.error", "Cloud IP search error: " + ex.Message);
        }        finally
        {
            isSearching = false;
            StateHasChanged();
        }
    }    private List<CloudMatch> SearchAzureRanges(IPAddress enteredIp, string jsonContent)
    {
        var matchedServices = new List<CloudMatch>();
        
        try
        {
            var azureData = JsonSerializer.Deserialize<AzureIpRanges>(jsonContent);
            
            if (azureData?.values != null)
            {
                foreach (var value in azureData.values)
                {
                    if (value.properties?.addressPrefixes != null)
                    {
                        foreach (var prefix in value.properties.addressPrefixes)
                        {
                            if (IsIpInRange(enteredIp, prefix) && !string.IsNullOrEmpty(value.name))
                            {
                                var match = new CloudMatch
                                {
                                    ServiceInfo = value.name,
                                    CidrRange = prefix
                                };
                                // Only add if we don't already have this exact match
                                if (!matchedServices.Any(m => m.ServiceInfo == match.ServiceInfo && m.CidrRange == match.CidrRange))
                                {
                                    matchedServices.Add(match);
                                }
                                break; // Only add each service once per address prefix
                            }
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error searching Azure ranges: {ex.Message}");
        }
        
        return matchedServices;
    }    private List<CloudMatch> SearchAwsRanges(IPAddress enteredIp, string jsonContent)
    {
        var matchedServices = new List<CloudMatch>();
        
        try
        {
            var awsData = JsonSerializer.Deserialize<AwsIpRanges>(jsonContent);
            
            // Search IPv4 prefixes
            if (awsData?.prefixes != null)
            {
                foreach (var prefix in awsData.prefixes)
                {
                    if (!string.IsNullOrEmpty(prefix.ip_prefix) && !string.IsNullOrEmpty(prefix.service))
                    {
                        if (IsIpInRange(enteredIp, prefix.ip_prefix))
                        {
                            string serviceInfo = $"{prefix.service} ({prefix.region})";
                            var match = new CloudMatch
                            {
                                ServiceInfo = serviceInfo,
                                CidrRange = prefix.ip_prefix
                            };
                            // Only add if we don't already have this exact match
                            if (!matchedServices.Any(m => m.ServiceInfo == match.ServiceInfo && m.CidrRange == match.CidrRange))
                            {
                                matchedServices.Add(match);
                            }
                        }
                    }
                }
            }
            
            // Search IPv6 prefixes
            if (awsData?.ipv6_prefixes != null)
            {
                foreach (var prefix in awsData.ipv6_prefixes)
                {
                    if (!string.IsNullOrEmpty(prefix.ipv6_prefix) && !string.IsNullOrEmpty(prefix.service))
                    {
                        if (IsIpInRange(enteredIp, prefix.ipv6_prefix))
                        {
                            string serviceInfo = $"{prefix.service} ({prefix.region})";
                            var match = new CloudMatch
                            {
                                ServiceInfo = serviceInfo,
                                CidrRange = prefix.ipv6_prefix
                            };
                            // Only add if we don't already have this exact match
                            if (!matchedServices.Any(m => m.ServiceInfo == match.ServiceInfo && m.CidrRange == match.CidrRange))
                            {
                                matchedServices.Add(match);
                            }
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error searching AWS ranges: {ex.Message}");
        }
        
        return matchedServices;
    }    private List<CloudMatch> SearchGcpRanges(IPAddress enteredIp, string jsonContent)
    {
        var matchedServices = new List<CloudMatch>();
        
        try
        {
            var gcpData = JsonSerializer.Deserialize<GcpIpRanges>(jsonContent);
            
            if (gcpData?.prefixes != null)
            {
                foreach (var prefix in gcpData.prefixes)
                {
                    string? ipRange = prefix.ipv4Prefix ?? prefix.ipv6Prefix;
                    if (!string.IsNullOrEmpty(ipRange) && !string.IsNullOrEmpty(prefix.service))
                    {
                        if (IsIpInRange(enteredIp, ipRange))
                        {
                            string serviceInfo = $"{prefix.service} ({prefix.scope ?? "Global"})";
                            var match = new CloudMatch
                            {
                                ServiceInfo = serviceInfo,
                                CidrRange = ipRange
                            };
                            // Only add if we don't already have this exact match
                            if (!matchedServices.Any(m => m.ServiceInfo == match.ServiceInfo && m.CidrRange == match.CidrRange))
                            {
                                matchedServices.Add(match);
                            }
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error searching GCP ranges: {ex.Message}");
        }
          return matchedServices;
    }

    private List<CloudMatch> SearchOracleRanges(IPAddress enteredIp, string jsonContent)
    {
        var matchedServices = new List<CloudMatch>();
        
        try
        {
            var oracleData = JsonSerializer.Deserialize<OracleIpRanges>(jsonContent);
            
            if (oracleData?.regions != null)
            {
                foreach (var region in oracleData.regions)
                {
                    if (region.cidrs != null)
                    {
                        foreach (var cidrInfo in region.cidrs)
                        {
                            if (!string.IsNullOrEmpty(cidrInfo.cidr) && cidrInfo.tags != null && cidrInfo.tags.Any())
                            {
                                if (IsIpInRange(enteredIp, cidrInfo.cidr))
                                {
                                    string serviceInfo = $"{string.Join(", ", cidrInfo.tags)} ({region.region})";
                                    var match = new CloudMatch
                                    {
                                        ServiceInfo = serviceInfo,
                                        CidrRange = cidrInfo.cidr
                                    };
                                    // Only add if we don't already have this exact match
                                    if (!matchedServices.Any(m => m.ServiceInfo == match.ServiceInfo && m.CidrRange == match.CidrRange))
                                    {
                                        matchedServices.Add(match);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error searching Oracle ranges: {ex.Message}");
        }
        
        return matchedServices;    }    private bool IsValidIPAddress(string input)
    {
        // Parse the input to extract just the IP address part
        string actualIpAddress;
        
        if (input.Contains(';'))
        {
            var parts = input.Split(';', 2);
            actualIpAddress = parts[0].Trim();
        }
        else
        {
            actualIpAddress = input.Trim();
        }

        if (!IPAddress.TryParse(actualIpAddress, out IPAddress? parsedIP))
            return false;

        return IsPublicRoutableIP(parsedIP);
    }

    private bool IsPublicRoutableIP(IPAddress ip)
    {
        // Check if it's a valid public routable IP address
        if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
        {
            return IsPublicIPv4(ip);
        }
        else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)
        {
            return IsPublicIPv6(ip);
        }

        return false;
    }

    private bool IsPublicIPv4(IPAddress ip)
    {
        byte[] bytes = ip.GetAddressBytes();
        
        // Check for private/reserved IPv4 ranges
        
        // 0.0.0.0/8 - "This network"
        if (bytes[0] == 0)
            return false;
            
        // 10.0.0.0/8 - Private network
        if (bytes[0] == 10)
            return false;
            
        // 100.64.0.0/10 - Carrier-grade NAT
        if (bytes[0] == 100 && (bytes[1] & 0xC0) == 64)
            return false;
            
        // 127.0.0.0/8 - Loopback
        if (bytes[0] == 127)
            return false;
            
        // 169.254.0.0/16 - Link-local
        if (bytes[0] == 169 && bytes[1] == 254)
            return false;
            
        // 172.16.0.0/12 - Private network
        if (bytes[0] == 172 && (bytes[1] & 0xF0) == 16)
            return false;
            
        // 192.0.0.0/24 - IETF Protocol Assignments
        if (bytes[0] == 192 && bytes[1] == 0 && bytes[2] == 0)
            return false;
            
        // 192.0.2.0/24 - TEST-NET-1
        if (bytes[0] == 192 && bytes[1] == 0 && bytes[2] == 2)
            return false;
            
        // 192.88.99.0/24 - 6to4 Relay Anycast
        if (bytes[0] == 192 && bytes[1] == 88 && bytes[2] == 99)
            return false;
            
        // 192.168.0.0/16 - Private network
        if (bytes[0] == 192 && bytes[1] == 168)
            return false;
            
        // 198.18.0.0/15 - Network interconnect device benchmark testing
        if (bytes[0] == 198 && (bytes[1] & 0xFE) == 18)
            return false;
            
        // 198.51.100.0/24 - TEST-NET-2
        if (bytes[0] == 198 && bytes[1] == 51 && bytes[2] == 100)
            return false;
            
        // 203.0.113.0/24 - TEST-NET-3
        if (bytes[0] == 203 && bytes[1] == 0 && bytes[2] == 113)
            return false;
            
        // 224.0.0.0/4 - Multicast
        if ((bytes[0] & 0xF0) == 224)
            return false;
            
        // 240.0.0.0/4 - Reserved for future use
        if ((bytes[0] & 0xF0) == 240)
            return false;
            
        // 255.255.255.255/32 - Limited broadcast
        if (bytes[0] == 255 && bytes[1] == 255 && bytes[2] == 255 && bytes[3] == 255)
            return false;

        return true;
    }

    private bool IsPublicIPv6(IPAddress ip)
    {
        byte[] bytes = ip.GetAddressBytes();
        
        // Check for private/reserved IPv6 ranges
        
        // ::1/128 - Loopback
        if (ip.Equals(IPAddress.IPv6Loopback))
            return false;
            
        // ::/128 - Unspecified
        if (ip.Equals(IPAddress.IPv6Any))
            return false;
            
        // ::ffff:0:0/96 - IPv4-mapped IPv6
        if (bytes[0] == 0 && bytes[1] == 0 && bytes[2] == 0 && bytes[3] == 0 &&
            bytes[4] == 0 && bytes[5] == 0 && bytes[6] == 0 && bytes[7] == 0 &&
            bytes[8] == 0 && bytes[9] == 0 && bytes[10] == 0xFF && bytes[11] == 0xFF)
            return false;
            
        // fe80::/10 - Link-local
        if (bytes[0] == 0xFE && (bytes[1] & 0xC0) == 0x80)
            return false;
            
        // fc00::/7 - Unique local address
        if ((bytes[0] & 0xFE) == 0xFC)
            return false;
            
        // ff00::/8 - Multicast
        if (bytes[0] == 0xFF)
            return false;
            
        // 2001:db8::/32 - Documentation
        if (bytes[0] == 0x20 && bytes[1] == 0x01 && bytes[2] == 0x0D && bytes[3] == 0xB8)
            return false;

        return true;
    }

    private bool IsIpInRange(IPAddress ip, string cidrRange)
    {
        try
        {
            // Split CIDR range into IP and prefix length
            string[] parts = cidrRange.Split('/');
            if (parts.Length != 2)
                return false;

            IPAddress networkAddress = IPAddress.Parse(parts[0]);
            int prefixLength = int.Parse(parts[1]);

            // Convert IP addresses to bytes for comparison
            byte[] ipBytes = ip.GetAddressBytes();
            byte[] networkBytes = networkAddress.GetAddressBytes();

            // Check if both IPs are the same version (IPv4 = 4 bytes, IPv6 = 16 bytes)
            if (ipBytes.Length != networkBytes.Length)
                return false;

            // Validate prefix length based on IP version
            int maxPrefixLength = ipBytes.Length * 8; // 32 for IPv4, 128 for IPv6
            if (prefixLength < 0 || prefixLength > maxPrefixLength)
                return false;

            // Calculate the number of full bytes and remaining bits to compare
            int numBytes = prefixLength / 8;
            int remainingBits = prefixLength % 8;

            // Compare full bytes
            for (int i = 0; i < numBytes && i < ipBytes.Length; i++)
            {
                if (ipBytes[i] != networkBytes[i])
                    return false;
            }

            // Compare remaining bits in the next byte (if any)
            if (remainingBits > 0 && numBytes < ipBytes.Length)
            {
                // Create a mask for the remaining bits
                // For example, if remainingBits = 5, mask = 11111000 = 0xF8
                int mask = (0xFF << (8 - remainingBits)) & 0xFF;
                
                if ((ipBytes[numBytes] & mask) != (networkBytes[numBytes] & mask))
                    return false;
            }

            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in IsIpInRange for CIDR '{cidrRange}': {ex.Message}");
            return false;
        }
    }

    private string GetScoreClass(int score)
    {
        if (score < 25) return "text-success";
        if (score < 75) return "text-warning";
        return "text-danger";
    }

    private bool HasSearchResults()
    {
        return (azureMatchedServices != null && azureMatchedServices.Any()) ||
               (awsMatchedServices != null && awsMatchedServices.Any()) ||
               (gcpMatchedServices != null && gcpMatchedServices.Any()) ||
               (oracleMatchedServices != null && oracleMatchedServices.Any());
    }

    private class CloudMatch
    {
        public string ServiceInfo { get; set; } = string.Empty;
        public string CidrRange { get; set; } = string.Empty;
        
        public override string ToString()
        {
            return $"{ServiceInfo} (CIDR: {CidrRange})";
        }
    }

    private class AzureIpRanges
    {
        public int changeNumber { get; set; }
        public string? cloud { get; set; }
        public List<AzureService>? values { get; set; }
    }

    private class AzureService
    {
        public string? name { get; set; }
        public string? id { get; set; }
        public ServiceProperties? properties { get; set; }
    }

    private class ServiceProperties
    {
        public string[]? addressPrefixes { get; set; }
        public string[]? networkFeatures { get; set; }
        public string[]? platformFeatures { get; set; }
        public string? systemService { get; set; }
    }

    private class AwsIpRanges
    {
        public string? syncToken { get; set; }
        public string? createDate { get; set; }
        public List<AwsPrefix>? prefixes { get; set; }
        public List<AwsPrefix>? ipv6_prefixes { get; set; }
    }

    private class AwsPrefix
    {
        public string? ip_prefix { get; set; }
        public string? ipv6_prefix { get; set; }
        public string? region { get; set; }
        public string? service { get; set; }
        public string? network_border_group { get; set; }
    }

    private class GcpIpRanges
    {
        public string? syncToken { get; set; }
        public string? creationTime { get; set; }
        public List<GcpPrefix>? prefixes { get; set; }
    }    private class GcpPrefix
    {
        public string? ipv4Prefix { get; set; }
        public string? ipv6Prefix { get; set; }
        public string? service { get; set; }
        public string? scope { get; set; }
    }

    private class OracleIpRanges
    {
        public string? last_updated_timestamp { get; set; }
        public List<OracleRegion>? regions { get; set; }
    }

    private class OracleRegion
    {
        public string? region { get; set; }
        public List<OracleCidr>? cidrs { get; set; }
    }

    private class OracleCidr
    {
        public string? cidr { get; set; }
        public List<string>? tags { get; set; }
    }
}